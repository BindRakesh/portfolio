<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rakesh's Office Portfolio</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #instructions {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            font-family: monospace;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <div id="instructions">CLICK the <b>Monitor</b> or <b>Laptop</b> to read info on their screens.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. SETUP & SCENE ---
        const scene = new THREE.Scene();
        // Evening Fog for depth
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(3, 3, 5); // Angle to see window and desk

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        // --- 2. TEXTURE GENERATOR (For Text on Screens) ---
        function createTextTexture(textArray, bgColor = '#000') {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, 512, 512);

            // Text
            ctx.fillStyle = '#00ff00'; // Matrix green text
            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'left';
            
            let y = 60;
            textArray.forEach(line => {
                ctx.fillText(line, 20, y);
                y += 50;
            });

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Default Screen Textures
        const defaultMonitorTex = createTextTexture(["SYSTEM READY.", "CLICK TO VIEW SKILLS."], "#001133");
        const defaultLaptopTex = createTextTexture(["USER: Rakesh", "STATUS: Online", "CLICK FOR BIO"], "#110033");

        // --- 3. LIGHTING (Evening Vibe) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Dim ambient
        scene.add(ambientLight);

        // Warm Desk Lamp Light
        const deskLight = new THREE.PointLight(0xffaa00, 5, 10);
        deskLight.position.set(1, 3, 1);
        deskLight.castShadow = true;
        scene.add(deskLight);

        // Blueish City Light from Window
        const cityLight = new THREE.DirectionalLight(0x4444ff, 1);
        cityLight.position.set(-10, 5, -5);
        scene.add(cityLight);

        // --- 4. MATERIALS ---
        const wallMat = new THREE.MeshStandardMaterial({ color: 0xDDDDDD, side: THREE.DoubleSide });
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 });
        const glassMat = new THREE.MeshPhysicalMaterial({ 
            color: 0x88ccff, transmission: 0.5, opacity: 0.3, transparent: true, roughness: 0 
        });
        const woodMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
        const blackPlasticMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });

        // --- 5. BUILD THE OFFICE ---

        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Back Wall (with Window cutout logic simulated by 2 parts)
        // Part 1: Bottom wall
        const wallBottom = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 0.2), wallMat);
        wallBottom.position.set(0, 1, -4);
        scene.add(wallBottom);
        // Part 2: Top wall
        const wallTop = new THREE.Mesh(new THREE.BoxGeometry(20, 2, 0.2), wallMat);
        wallTop.position.set(0, 7, -4);
        scene.add(wallTop);
        // Part 3: Side pillars for window
        const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.2), wallMat);
        wallLeft.position.set(-8, 4, -4);
        const wallRight = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.2), wallMat);
        wallRight.position.set(8, 4, -4);
        scene.add(wallLeft, wallRight);

        // The Window Glass
        const windowGlass = new THREE.Mesh(new THREE.PlaneGeometry(12, 4), glassMat);
        windowGlass.position.set(0, 4, -4);
        scene.add(windowGlass);

        // --- 6. THE CITY & METRO (Outside) ---
        const cityGroup = new THREE.Group();
        // Create random buildings
        const buildingGeo = new THREE.BoxGeometry(1, 1, 1);
        for(let i=0; i<30; i++) {
            const h = Math.random() * 10 + 5;
            const building = new THREE.Mesh(buildingGeo, new THREE.MeshBasicMaterial({ color: 0x050510 }));
            building.scale.set(2 + Math.random()*3, h, 2 + Math.random()*3);
            building.position.set(
                (Math.random() - 0.5) * 40,
                h/2 - 5, // shift down so they look distant
                -15 - Math.random() * 20
            );
            
            // Add "Windows" (emissive dots)
            const winGeo = new THREE.PlaneGeometry(0.2, 0.2);
            const winMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            for(let j=0; j<5; j++){
                const win = new THREE.Mesh(winGeo, winMat);
                win.position.set(0, (Math.random()-0.5)*h, 0.51);
                building.add(win);
            }
            cityGroup.add(building);
        }
        scene.add(cityGroup);

        // The Metro Track & Train
        const trainGroup = new THREE.Group();
        const trainBody = new THREE.Mesh(new THREE.BoxGeometry(6, 0.8, 0.8), new THREE.MeshBasicMaterial({ color: 0xcccccc }));
        const trainLight = new THREE.PointLight(0xff0000, 2, 5); // Tail light
        trainLight.position.set(-3, 0, 0);
        trainGroup.add(trainBody, trainLight);
        trainGroup.position.set(20, 2, -10); // Start far right
        scene.add(trainGroup);

        // --- 7. FURNITURE (High Detail) ---

        // DESK
        const deskGroup = new THREE.Group();
        const deskTop = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 2.5), woodMat);
        deskTop.position.y = 1.5;
        deskTop.castShadow = true;
        deskTop.receiveShadow = true;
        
        const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 1.5);
        const leg1 = new THREE.Mesh(legGeo, metalMat); leg1.position.set(-2.2, 0.75, 1);
        const leg2 = new THREE.Mesh(legGeo, metalMat); leg2.position.set(2.2, 0.75, 1);
        const leg3 = new THREE.Mesh(legGeo, metalMat); leg3.position.set(-2.2, 0.75, -1);
        const leg4 = new THREE.Mesh(legGeo, metalMat); leg4.position.set(2.2, 0.75, -1);
        
        deskGroup.add(deskTop, leg1, leg2, leg3, leg4);
        scene.add(deskGroup);

        // CHAIR
        const chairGroup = new THREE.Group();
        const seat = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.2), blackPlasticMat);
        seat.position.y = 1;
        const back = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.1), blackPlasticMat);
        back.position.set(0, 1.6, 0.6);
        const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1), metalMat);
        stem.position.y = 0.5;
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.1), blackPlasticMat);
        base.position.y = 0.1;
        
        chairGroup.add(seat, back, stem, base);
        chairGroup.position.set(0, 0, 1.8);
        chairGroup.rotation.y = -0.2; // Slight swivel
        scene.add(chairGroup);

        // DUSTBIN
        const binGeo = new THREE.CylinderGeometry(0.3, 0.25, 0.6, 16, 1, true); // Open top
        const binMat = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide, wireframe: true });
        const bin = new THREE.Mesh(binGeo, binMat);
        bin.position.set(1.5, 0.3, 0.5);
        scene.add(bin);

        // --- 8. INTERACTIVE TECH ---
        const interactables = [];

        // MONITOR
        const monitorGroup = new THREE.Group();
        const monStand = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.1, 0.6), metalMat);
        monStand.position.y = 1.8;
        const monFrame = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.0, 0.1), blackPlasticMat);
        monFrame.position.y = 2.2;
        // The Screen Plane
        const monScreenGeo = new THREE.PlaneGeometry(1.5, 0.9);
        const monScreenMat = new THREE.MeshBasicMaterial({ map: defaultMonitorTex });
        const monScreen = new THREE.Mesh(monScreenGeo, monScreenMat);
        monScreen.position.set(0, 2.2, 0.06);
        monScreen.name = "Monitor";
        
        monitorGroup.add(monStand, monFrame, monScreen);
        monitorGroup.position.z = -0.5;
        scene.add(monitorGroup);
        interactables.push(monScreen);

        // LAPTOP
        const laptopGroup = new THREE.Group();
        const lapBase = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.05, 0.6), metalMat);
        lapBase.position.y = 1.55;
        const lapScreenGeo = new THREE.PlaneGeometry(0.7, 0.5);
        const lapScreenMat = new THREE.MeshBasicMaterial({ map: defaultLaptopTex });
        const lapScreen = new THREE.Mesh(lapScreenGeo, lapScreenMat);
        lapScreen.position.set(0, 1.8, -0.25);
        lapScreen.rotation.x = 0.2; // Tilt
        lapScreen.name = "Laptop";

        laptopGroup.add(lapBase, lapScreen);
        laptopGroup.position.set(1.2, 0, 0.5);
        laptopGroup.rotation.y = -0.5;
        scene.add(laptopGroup);
        interactables.push(lapScreen);


        // --- 9. LOGIC ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        window.addEventListener('click', (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(interactables);

            if(intersects.length > 0) {
                const name = intersects[0].object.name;
                if(name === "Monitor") {
                    monScreen.material.map = createTextTexture([
                        "SKILLS:", 
                        "- JavaScript / TypeScript", 
                        "- Python / Backend", 
                        "- Three.js / WebGL", 
                        "- Cloud Architecture"
                    ]);
                    monScreen.material.needsUpdate = true;
                }
                if(name === "Laptop") {
                    lapScreen.material.map = createTextTexture([
                        "ABOUT ME:", 
                        "I am Rakesh.", 
                        "Developer & Tech Enthusiast.", 
                        "Based in the City.", 
                        "Driven by Logic & Art."
                    ], "#330000");
                    lapScreen.material.needsUpdate = true;
                }
            }
        });

        // --- 10. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // Animate Train (Metro)
            trainGroup.position.x -= 0.1; // Move left
            if(trainGroup.position.x < -30) {
                trainGroup.position.x = 30; // Reset loop
            }

            renderer.render(scene, camera);
        }

        // Resize support
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
